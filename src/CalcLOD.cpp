#include "CalcLOD.h"

#include "Debug.h"
#include "PLYReader.h"
#include "TriangleMesh.h"

#include <map>
#include <set>
#include <tinyply.h>
#include <vector>

using namespace tinyply;

void modelToPly(const std::string &filename, const TriangleMesh &mesh) {
  std::filebuf fb;
  fb.open(filename + "-binary.ply", std::ios::out); // | std::ios::binary);
  std::ostream outstream_binary(&fb);
  if (outstream_binary.fail())
    throw std::runtime_error("failed to open " + filename);

  PlyFile mf;
  auto aux_v = mesh.exportVertices();
  mf.add_properties_to_element(
      "vertex", {"x", "y", "z"}, Type::FLOAT32, aux_v.size(),
      reinterpret_cast<uint8_t *>(aux_v.data()), Type::INVALID, 0);

  auto aux = mesh.exportTriangles();
  mf.add_properties_to_element(
      "face", {"vertex_indices"}, Type::UINT32, aux.size(),
      reinterpret_cast<uint8_t *>(aux.data()), Type::UINT8, 3);
  mf.get_comments().push_back("generated by tinyply 2.3");

  mf.write(outstream_binary, false);
}

void cubize(const Octree &octree, TriangleMesh &mesh, int level,
            int maxLevel = -1, bool showCubes = false) {
  if (showCubes) {
    glm::vec3 pos = octree.getPoss();
    glm::vec3 size = octree.getSize();
    mesh.buildCube(pos, size);
  }
  if (octree.getQttyElements() > 0) {
    if (!showCubes) {
      glm::vec3 pos = octree.getPoss();
      glm::vec3 size = octree.getSize();
      mesh.buildCube(pos, size);
    }
  } else if (maxLevel == -1 || level < maxLevel) {
    for (unsigned int i = 0; i < Octree::VECT_SIZE; ++i) {
      const Octree c = octree.getChildren(i);
      if (c.getQtty() >= 1) {
        cubize(c, mesh, level + 1, maxLevel, showCubes);
      }
    }
  }
}

void midSimplify(const Octree &octree, TriangleMesh &mesh,
                 std::map<int, int> &oldVertexToNew, int actualLevel,
                 int level) {
  if (octree.getQttyChildrens() > 0 && actualLevel < level) {
    for (unsigned int i = 0; i < Octree::VECT_SIZE; ++i) {
      midSimplify(octree.getChildren(i), mesh, oldVertexToNew, actualLevel + 1,
                  level);
    }
  } else if (octree.getQttyElements() > 0) {
    int size = octree.getQttyElements();
    glm::vec3 mean(0.0f);
    for (unsigned int i = 0; i < size; ++i) {
      mean += octree.getElementVec(i);
      oldVertexToNew[octree.getElementIndex(i)] = mesh.getVerticesSize();
    }
    mean /= size;
    mesh.addVertex(mean);
  }
}

void simplify(Octree &octree, const TriangleMesh &old_mesh,
              TriangleMesh &new_mesh, int level) {
  octree.cut(level);
  std::map<int, int> oldVertexToNew;
  midSimplify(octree, new_mesh, oldVertexToNew, 0, level);
  std::set<int3> triangles;
  for (const auto &tri : old_mesh.getTriangles()) {
    int x = oldVertexToNew[tri.x];
    int y = oldVertexToNew[tri.y];
    int z = oldVertexToNew[tri.z];
    if (x != y && x != z && y != z) {
      triangles.insert(int3{x, y, z});
    }
  }
  for (auto it = triangles.begin(); it != triangles.end(); ++it) {
    new_mesh.addTriangle(it->x, it->y, it->z);
  }
}

CalcLOD::CalcLOD(int argc, char **argv) {
  TriangleMesh *mesh = new TriangleMesh();
  bool bSuccess = PLYReader::readMesh(std::string(argv[1]), *mesh);
  if (not bSuccess) {
    std::cerr << "error loading model" << std::endl;
    return;
  }

  Octree octree(mesh->getVertices());

  TriangleMesh *new_mesh = new TriangleMesh();
  int level = octree.getMaxLevel() - LOD_LEVEL;
  if (LOD_LEVEL == 0) {
    cubize(octree, *new_mesh, 0, -1, false);
  } else if (level > 0) {
    simplify(octree, *mesh, *new_mesh, level);
  } else {
    cerr << "Error LOD > octree max level" << std::endl;
  }
  modelToPly("testing", *new_mesh);
}
